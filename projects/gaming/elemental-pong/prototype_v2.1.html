<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELEMENTAL PONG - Enhanced v2.1</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #0d1117 50%, #161b22 100%);
            min-height: 100vh;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            background: #000;
            border: 3px solid #333;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(0, 243, 255, 0.15),
                        inset 0 0 60px rgba(0, 0, 0, 0.5);
            display: block;
        }
        
        #hud {
            position: absolute;
            top: -50px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            color: #fff;
        }
        
        .score-box { text-align: center; }
        .score-label { font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 2px; }
        .score-value { font-size: 48px; font-weight: 900; text-shadow: 0 0 20px currentColor; }
        #scorePlayer { color: #00f3ff; }
        #scoreEnemy { color: #ff0055; }
        
        #centerInfo {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #ffcc00;
        }
        
        #waveDisplay {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: pulse 2s infinite;
        }
        
        #streakDisplay {
            font-size: 11px;
            color: #00ff88;
            margin-top: 5px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #elementBar {
            position: absolute;
            bottom: -45px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .element-pill {
            padding: 8px 16px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s;
            opacity: 0.4;
        }
        
        .element-pill.active {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 20px currentColor;
        }
        
        #chronoContainer {
            position: absolute;
            bottom: -70px;
            width: 200px;
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
        }
        
        #chronoFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #bc13fe, #00f3ff);
            transition: width 0.1s;
        }
        
        #chronoLabel {
            position: absolute;
            bottom: -85px;
            font-size: 10px;
            color: #bc13fe;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .menu {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            z-index: 100;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .menu::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(0, 243, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(188, 19, 254, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 204, 0, 0.05) 0%, transparent 70%);
            animation: menuGlow 8s ease-in-out infinite;
        }
        
        @keyframes menuGlow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .menu.hidden { display: none !important; }
        
        .menu h1 {
            position: relative;
            font-size: 52px;
            font-weight: 900;
            background: linear-gradient(135deg, #00f3ff, #bc13fe, #ffcc00, #00f3ff);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            animation: titleGlow 3s ease-in-out infinite, titleGradient 8s ease infinite;
            text-shadow: 0 0 30px rgba(0, 243, 255, 0.3);
        }
        
        @keyframes titleGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .menu h2 {
            position: relative;
            font-size: 16px;
            color: #888;
            margin-bottom: 40px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        
        .menu button {
            background: linear-gradient(135deg, #00f3ff, #00a5aa);
            border: none;
            padding: 15px 50px;
            font-size: 18px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            color: #000;
            cursor: pointer;
            border-radius: 30px;
            margin: 10px;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .menu button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.5);
        }
        
        .menu button.secondary {
            background: transparent;
            border: 2px solid #444;
            color: #888;
        }
        
        .menu button.secondary:hover {
            border-color: #fff;
            color: #fff;
        }
        
        #gameOverStats { text-align: center; margin: 20px 0; }
        #finalScore { font-size: 36px; color: #ffcc00; }
        #highScoreDisplay { font-size: 16px; color: #00ff88; margin-top: 10px; }
        
        .controls-info {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
            text-align: center;
            line-height: 1.8;
        }
        
        .controls-info kbd {
            background: #222;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #444;
            color: #aaa;
        }
        
        .mode-buttons { display: flex; gap: 15px; margin: 20px 0; }
        
        .mode-btn {
            padding: 12px 25px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #444;
            border-radius: 10px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .mode-btn:hover, .mode-btn.active {
            border-color: #00f3ff;
            background: rgba(0, 243, 255, 0.2);
        }
        
        @keyframes titleGlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        #achievementToast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #00f3ff, #bc13fe);
            padding: 15px 25px;
            border-radius: 10px;
            color: #000;
            font-weight: bold;
            transform: translateX(400px);
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 200;
        }
        
        #achievementToast.show { transform: translateX(0); }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div class="score-box">
                <div class="score-label">Player</div>
                <div class="score-value" id="scorePlayer">0</div>
            </div>
            <div id="centerInfo">
                <div id="waveDisplay">WAVE 1</div>
                <div id="streakDisplay">PERFECT!</div>
            </div>
            <div class="score-box">
                <div class="score-label">Enemy</div>
                <div class="score-value" id="scoreEnemy">0</div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        
        <div id="elementBar"></div>
        <div id="chronoContainer">
            <div id="chronoFill"></div>
        </div>
        <div id="chronoLabel">CHRONO BREAK [C]</div>
        
        <!-- Main Menu -->
        <div id="mainMenu" class="menu">
            <h1>ELEMENTAL PONG</h1>
            <h2>Chrono & Chaos v2.1</h2>
            
            <div class="mode-buttons">
                <button class="mode-btn active" data-mode="single">Single</button>
                <button class="mode-btn" data-mode="local2p">2 Players</button>
            </div>
            
            <button onclick="startGame()">START</button>
            <button class="secondary" onclick="showSettings()">Settings</button>
            
            <div class="controls-info">
                <kbd>‚Üê ‚Üí</kbd> Move &nbsp;|&nbsp; <kbd>SPACE</kbd> Charge &nbsp;|&nbsp; <kbd>C</kbd> Chrono &nbsp;|&nbsp; <kbd>P</kbd> Pause
            </div>
        </div>
        
        <!-- Pause Menu -->
        <div id="pauseMenu" class="menu hidden">
            <h1>PAUSED</h1>
            <button onclick="resumeGame()">RESUME</button>
            <button class="secondary" onclick="returnToMenu()">MENU</button>
        </div>
        
        <!-- Game Over -->
        <div id="gameOverMenu" class="menu hidden">
            <h1>GAME OVER</h1>
            <div id="gameOverStats">
                <div id="finalScore">Score: 0</div>
                <div id="highScoreDisplay">Record: 0</div>
            </div>
            <button onclick="startGame()">RETRY</button>
            <button class="secondary" onclick="returnToMenu()">MENU</button>
        </div>
        
        <!-- Settings -->
        <div id="settingsMenu" class="menu hidden">
            <h1>SETTINGS</h1>
            <div style="margin: 20px 0; text-align: left;">
                <label style="display: flex; justify-content: space-between; width: 200px; margin: 10px 0; color: #fff;">
                    <span>Sound</span>
                    <input type="checkbox" id="soundToggle" checked>
                </label>
            </div>
            <button onclick="hideSettings()">BACK</button>
        </div>
    </div>
    
    <div id="achievementToast">üèÜ Achievement!</div>

<script>
// Audio System
const AudioSys = {
    ctx: null, enabled: true,
    init() { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
    play(type) {
        if (!this.enabled || !this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        const now = this.ctx.currentTime;
        switch(type) {
            case 'hit': osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(200, now + 0.1); gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); break;
            case 'score': osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(600, now + 0.15); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15); osc.start(now); osc.stop(now + 0.15); break;
            case 'power': osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(880, now + 0.2); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2); osc.start(now); osc.stop(now + 0.2); break;
            case 'chrono': osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.3); gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3); osc.start(now); osc.stop(now + 0.3); break;
            case 'lose': osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.5); gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5); osc.start(now); osc.stop(now + 0.5); break;
        }
    }
};

const CONFIG = { canvasWidth: 400, canvasHeight: 600, paddleWidth: 80, paddleHeight: 12, paddleSpeed: 8, ballSpeed: 5, ballRadius: 10, winningScore: 10, chronoCost: 30 };

const ELEMENTS = {
    FIRE: { name: 'Fire', color: '#ff4444', emoji: 'üî•', effect: 'speed' },
    ICE: { name: 'Ice', color: '#00ffff', emoji: '‚ùÑÔ∏è', effect: 'slow' },
    LIGHTNING: { name: 'Lightning', color: '#ffff00', emoji: '‚ö°', effect: 'erratic' },
    EARTH: { name: 'Earth', color: '#8B4513', emoji: 'üåç', effect: 'heavy' },
    AIR: { name: 'Air', color: '#87ceeb', emoji: 'üí®', effect: 'curve' },
    WATER: { name: 'Water', color: '#0066ff', emoji: 'üíß', effect: 'bounce' }
};

let game = {
    screen: 'menu', mode: 'single', running: false, paused: false,
    score: { player: 0, enemy: 0 },
    highScore: parseInt(localStorage.getItem('elementalPongHighScore')) || 0,
    level: 1, streak: 0, maxStreak: 0, charge: 0, chrono: 100,
    chronoActive: false, timeScale: 1, shake: 0, chronoUsed: 0,
    player: { x: 160, y: 550, width: 80, height: 12, speed: 8 },
    enemy: { x: 160, y: 38, width: 80, height: 12, speed: 3, baseSpeed: 3 },
    ball: { x: 200, y: 300, vx: 0, vy: 0, radius: 10, speed: 5 },
    currentElement: null, particles: [], powerups: [], achievements: [],
    keys: {}, lastTime: 0
};

const ACHIEVEMENTS = [
    { id: 'first_win', name: 'First Victory', condition: () => game.score.player >= 10 },
    { id: 'streak_5', name: 'Hot Streak', condition: () => game.streak >= 5 },
    { id: 'streak_10', name: 'On Fire!', condition: () => game.streak >= 10 },
    { id: 'wave_5', name: 'Survivor', condition: () => game.level >= 5 },
    { id: 'perfect', name: 'Perfect Game', condition: () => game.score.player >= 10 && game.streak >= 15 }
];

class Particle {
    constructor(x, y, color, type = 'normal') {
        this.x = x; this.y = y; this.color = color; this.type = type;
        this.vx = (Math.random() - 0.5) * (type === 'explosion' ? 10 : 4);
        this.vy = (Math.random() - 0.5) * (type === 'explosion' ? 10 : 4);
        this.life = 1; this.decay = 0.02 + Math.random() * 0.02;
        this.size = type === 'explosion' ? 8 : 3 + Math.random() * 3;
    }
    update() {
        if (game.timeScale < 1 && !game.chronoActive) {
            this.x += this.vx * 0.3; this.y += this.vy * 0.3;
        } else {
            this.x += this.vx; this.y += this.vy;
        }
        this.life -= this.decay;
    }
    draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class PowerUp {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.type = ['extraLife', 'slowDown', 'bigPaddle'][Math.floor(Math.random() * 3)];
        this.vy = 2; this.radius = 15; this.active = true;
    }
    update() {
        this.y += this.vy;
        if (this.y > 650 || this.y < -50) this.active = false;
    }
    draw() {
        if (!this.active) return;
        const colors = { extraLife: '#00ff88', slowDown: '#00ffff', bigPaddle: '#ffaa00' };
        const icons = { extraLife: '‚ù§Ô∏è', slowDown: '‚è±Ô∏è', bigPaddle: 'üìè' };
        ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
        ctx.fillStyle = colors[this.type];
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(icons[this.type], this.x, this.y);
        ctx.globalAlpha = 1;
    }
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function init() {
    document.addEventListener('keydown', (e) => {
        game.keys[e.key.toLowerCase()] = true;
        if (e.key.toLowerCase() === 'c' && game.chrono >= CONFIG.chronoCost && game.running) activateChrono();
        if (e.key.toLowerCase() === 'p' && game.running) togglePause();
    });
    document.addEventListener('keyup', (e) => game.keys[e.key.toLowerCase()] = false);
    document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            game.mode = btn.dataset.mode;
        });
    });
    document.getElementById('soundToggle').addEventListener('change', (e) => AudioSys.enabled = e.target.checked);
    createElementBar();
    document.getElementById('highScoreDisplay').textContent = `R√©cord: ${game.highScore}`;
    game.lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function createElementBar() {
    const bar = document.getElementById('elementBar');
    bar.innerHTML = '';
    Object.entries(ELEMENTS).forEach(([key, elem]) => {
        const pill = document.createElement('div');
        pill.className = 'element-pill';
        pill.id = `element-${key}`;
        pill.style.borderColor = elem.color;
        pill.style.color = elem.color;
        pill.textContent = elem.emoji;
        bar.appendChild(pill);
    });
}

function updateElementUI(elementKey) {
    document.querySelectorAll('.element-pill').forEach(p => p.classList.remove('active'));
    if (elementKey) document.getElementById(`element-${elementKey}`).classList.add('active');
}

function startGame() {
    AudioSys.init();
    game.screen = 'playing';
    game.running = true;
    game.paused = false;
    game.score = { player: 0, enemy: 0 };
    game.level = 1;
    game.streak = 0;
    game.maxStreak = 0;
    game.charge = 0;
    game.chrono = 100;
    game.chronoActive = false;
    game.timeScale = 1;
    game.chronoUsed = 0;
    game.particles = [];
    game.powerups = [];
    game.player.x = 160;
    game.enemy.x = 160;
    game.enemy.speed = game.enemy.baseSpeed;
    resetBall();
    document.querySelectorAll('.menu').forEach(m => m.classList.add('hidden'));
}

function resetBall() {
    const angle = (Math.random() * Math.PI / 4) - Math.PI / 8 + (Math.random() > 0.5 ? 0 : Math.PI);
    game.ball.x = 200;
    game.ball.y = 300;
    game.ball.vx = Math.sin(angle) * CONFIG.ballSpeed;
    game.ball.vy = Math.cos(angle) * CONFIG.ballSpeed;
    game.ball.speed = CONFIG.ballSpeed;
    game.currentElement = null;
    updateElementUI(null);
}

function activateChrono() {
    game.chrono -= CONFIG.chronoCost;
    game.chronoActive = true;
    game.timeScale = 0.3;
    game.chronoUsed++;
    AudioSys.play('chrono');
    setTimeout(() => {
        game.timeScale = 1;
        game.chronoActive = false;
    }, 2000);
}

function togglePause() {
    game.paused = !game.paused;
    document.getElementById('pauseMenu').classList.toggle('hidden', !game.paused);
}

function showWaveNotification() {
    // Wave notification shown in draw
}

function checkAchievements() {
    ACHIEVEMENTS.forEach(ach => {
        if (!game.achievements.includes(ach.id) && ach.condition()) {
            game.achievements.push(ach.id);
            showAchievement(ach.name);
            AudioSys.play('achievement');
        }
    });
}

function showAchievement(name) {
    const toast = document.getElementById('achievementToast');
    toast.textContent = `üèÜ ${name}`;
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 3000);
}

function gameOver() {
    game.running = false;
    AudioSys.play('lose');
    const totalScore = game.score.player + (game.level * 10);
    document.getElementById('finalScore').textContent = `Score: ${totalScore}`;
    document.getElementById('highScoreDisplay').textContent = `R√©cord: ${game.highScore}`;
    if (totalScore > game.highScore) {
        game.highScore = totalScore;
        localStorage.setItem('elementalPongHighScore', game.highScore);
        showAchievement('New Record!');
    }
    checkAchievements();
    document.getElementById('gameOverMenu').classList.remove('hidden');
}

function update(deltaTime) {
    if (!game.running || game.paused) return;
    const dt = deltaTime * game.timeScale;
    
    if (game.keys['arrowleft'] || game.keys['a']) game.player.x -= game.player.speed * dt * 60;
    if (game.keys['arrowright'] || game.keys['d']) game.player.x += game.player.speed * dt * 60;
    game.player.x = Math.max(0, Math.min(CONFIG.canvasWidth - game.player.width, game.player.x));
    
    if (game.mode === 'local2p') {
        if (game.keys['arrowup'] || game.keys['w']) game.enemy.x -= game.enemy.speed * dt * 60;
        if (game.keys['arrowdown'] || game.keys['s']) game.enemy.x += game.enemy.speed * dt * 60;
        game.enemy.x = Math.max(0, Math.min(CONFIG.canvasWidth - game.enemy.width, game.enemy.x));
    } else {
        const targetX = game.ball.x - game.enemy.width / 2;
        const reactionSpeed = game.enemy.speed + (game.level * 0.4);
        game.enemy.x += (targetX - game.enemy.x) * Math.min(0.12, reactionSpeed * 0.015);
        game.enemy.x = Math.max(0, Math.min(CONFIG.canvasWidth - game.enemy.width, game.enemy.x));
    }
    
    if (game.keys[' '] && game.charge < 100) {
        game.charge += dt * 40;
        if (game.charge >= 100) {
            game.charge = 100;
            const keys = Object.keys(ELEMENTS);
            game.currentElement = keys[Math.floor(Math.random() * keys.length)];
            updateElementUI(game.currentElement);
            AudioSys.play('power');
            for (let i = 0; i < 20; i++) {
                game.particles.push(new Particle(game.ball.x, game.ball.y, ELEMENTS[game.currentElement].color));
            }
        }
    }
    
    let speedMult = 1;
    if (game.currentElement) {
        const elem = ELEMENTS[game.currentElement];
        switch(elem.effect) {
            case 'speed': speedMult = 1.5; break;
            case 'slow': speedMult = 0.6; break;
            case 'erratic': game.ball.vx += (Math.random() - 0.5) * 0.5; break;
            case 'curve': game.ball.vx += Math.sin(Date.now() * 0.01) * 0.3; break;
        }
    }
    
    game.ball.x += game.ball.vx * speedMult * dt * 60;
    game.ball.y += game.ball.vy * speedMult * dt * 60;
    
    if (game.ball.x <= game.ball.radius || game.ball.x >= CONFIG.canvasWidth - game.ball.radius) {
        game.ball.vx *= -1;
        game.ball.x = Math.max(game.ball.radius, Math.min(CONFIG.canvasWidth - game.ball.radius, game.ball.x));
        AudioSys.play('hit');
        for (let i = 0; i < 5; i++) game.particles.push(new Particle(game.ball.x, game.ball.y, '#fff'));
    }
    
    if (game.ball.vy > 0 && game.ball.y + game.ball.radius >= game.player.y &&
        game.ball.y - game.ball.radius <= game.player.y + game.player.height &&
        game.ball.x >= game.player.x && game.ball.x <= game.player.x + game.player.width) {
        const hitPos = (game.ball.x - game.player.x) / game.player.width;
        const angle = (hitPos - 0.5) * Math.PI * 0.7;
        game.ball.vx = Math.sin(angle) * game.ball.speed;
        game.ball.vy = -Math.abs(Math.cos(angle) * game.ball.speed);
        game.streak++;
        game.maxStreak = Math.max(game.maxStreak, game.streak);
        game.charge = Math.min(100, game.charge + 5);
        game.shake = 5;
        AudioSys.play('hit');
        for (let i = 0; i < 10; i++) game.particles.push(new Particle(game.ball.x, game.ball.y, '#00f3ff'));
    }
    
    if (game.ball.vy < 0 && game.ball.y - game.ball.radius <= game.enemy.y + game.enemy.height &&
        game.ball.y + game.ball.radius >= game.enemy.y &&
        game.ball.x >= game.enemy.x && game.ball.x <= game.enemy.x + game.enemy.width) {
        const hitPos = (game.ball.x - game.enemy.x) / game.enemy.width;
        const angle = (hitPos - 0.5) * Math.PI * 0.7;
        game.ball.vx = Math.sin(angle) * game.ball.speed;
        game.ball.vy = Math.abs(Math.cos(angle) * game.ball.speed);
        game.streak = 0;
        game.shake = 5;
        AudioSys.play('hit');
    }
    
    if (game.ball.y > CONFIG.canvasHeight + 20) {
        game.score.enemy++;
        game.streak = 0;
        game.charge = Math.max(0, game.charge - 20);
        game.shake = 15;
        if (game.score.enemy >= CONFIG.winningScore) gameOver();
        else resetBall();
    }
    
    if (game.ball.y < -20) {
        game.score.player++;
        checkAchievements();
        AudioSys.play('score');
        if (Math.random() < 0.15) game.powerups.push(new PowerUp(50 + Math.random() * 300, 300));
        if (game.score.player >= CONFIG.winningScore) {
            game.score.player = 0;
            game.score.enemy = 0;
            game.level++;
            game.enemy.speed = game.enemy.baseSpeed + (game.level * 0.5);
        }
        resetBall();
    }
    
    game.powerups = game.powerups.filter(p => {
        p.update();
        p.draw();
        const dx = p.x - (game.player.x + game.player.width/2);
        const dy = p.y - (game.player.y + game.player.height/2);
        if (Math.sqrt(dx*dx + dy*dy) < p.radius + 30) {
            applyPowerUp(p.type);
            return false;
        }
        return p.active;
    });
    
    game.particles = game.particles.filter(p => {
        p.update();
        p.draw();
        return p.life > 0;
    });
    
    game.shake *= 0.9;
    if (game.chrono < 100) game.chrono += dt * 5;
    
    document.getElementById('scorePlayer').textContent = game.score.player;
    document.getElementById('scoreEnemy').textContent = game.score.enemy;
    document.getElementById('waveDisplay').textContent = `WAVE ${game.level}`;
    document.getElementById('streakDisplay').textContent = game.streak > 1 ? `STREAK x${game.streak}` : '';
    document.getElementById('streakDisplay').style.opacity = game.streak > 1 ? '1' : '0';
    document.getElementById('chronoFill').style.width = game.chrono + '%';
}

function applyPowerUp(type) {
    AudioSys.play('power');
    switch(type) {
        case 'slowDown': game.enemy.speed *= 0.5; setTimeout(() => game.enemy.speed = game.enemy.baseSpeed + (game.level * 0.5), 5000); break;
        case 'bigPaddle': game.player.width = 120; setTimeout(() => game.player.width = 80, 8000); break;
        case 'extraLife': game.score.player = Math.min(9, game.score.player + 2); break;
    }
}

function draw() {
    ctx.save();
    if (game.shake > 0.5) {
        ctx.translate((Math.random() - 0.5) * game.shake, (Math.random() - 0.5) * game.shake);
    }
    
    // Animated gradient background
    const gradient = ctx.createLinearGradient(0, 0, 400, 600);
    const hue = (Date.now() * 0.01) % 360;
    gradient.addColorStop(0, `hsla(${hue}, 20%, 5%, 1)`);
    gradient.addColorStop(0.5, `hsla(${(hue + 60) % 360}, 20%, 3%, 1)`);
    gradient.addColorStop(1, `hsla(${(hue + 120) % 360}, 20%, 5%, 1)`);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);
    
    // Center glow
    const centerGlow = ctx.createRadialGradient(200, 300, 0, 200, 300, 200);
    centerGlow.addColorStop(0, 'rgba(0, 243, 255, 0.05)');
    centerGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = centerGlow;
    ctx.fillRect(0, 0, 400, 600);
    
    // Grid lines with subtle color
    ctx.strokeStyle = 'rgba(50, 50, 50, 0.5)';
    ctx.setLineDash([15, 15]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 300);
    ctx.lineTo(400, 300);
    ctx.stroke();
    ctx.setLineDash([]);
    
    ctx.strokeStyle = 'rgba(30, 30, 40, 0.8)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 400; i += 40) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, 600);
        ctx.stroke();
    }
    for (let i = 0; i < 600; i += 40) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(400, i);
        ctx.stroke();
    }
    
    // Draw particles
    game.particles.forEach(p => p.draw());
    game.powerups.forEach(p => p.draw());
    
    // Ball glow effect
    if (game.currentElement) {
        const elem = ELEMENTS[game.currentElement];
        // Outer glow
        const glow = ctx.createRadialGradient(
            game.ball.x, game.ball.y, 0,
            game.ball.x, game.ball.y, game.ball.radius * 3
        );
        glow.addColorStop(0, elem.color + '80');
        glow.addColorStop(0.5, elem.color + '20');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(game.ball.x, game.ball.y, game.ball.radius * 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner glow
        ctx.fillStyle = elem.color + '30';
        ctx.beginPath();
        ctx.arc(game.ball.x, game.ball.y, game.ball.radius + 8, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Default white glow
        const glow = ctx.createRadialGradient(
            game.ball.x, game.ball.y, 0,
            game.ball.x, game.ball.y, game.ball.radius * 2
        );
        glow.addColorStop(0, 'rgba(255,255,255,0.5)');
        glow.addColorStop(0.5, 'rgba(255,255,255,0.1)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(game.ball.x, game.ball.y, game.ball.radius * 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    const ballColor = game.currentElement ? ELEMENTS[game.currentElement].color : '#fff';
    ctx.fillStyle = ballColor;
    ctx.shadowColor = ballColor;
    ctx.shadowBlur = 30;
    ctx.beginPath();
    ctx.arc(game.ball.x, game.ball.y, game.ball.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Ball core (white center)
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(game.ball.x, game.ball.y, game.ball.radius * 0.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Paddle glows
    ctx.fillStyle = '#00f3ff';
    ctx.shadowColor = '#00f3ff';
    ctx.shadowBlur = 20;
    ctx.fillRect(game.player.x, game.player.y, game.player.width, game.player.height);
    ctx.shadowBlur = 0;
    
    ctx.fillStyle = '#ff0055';
    ctx.shadowColor = '#ff0055';
    ctx.shadowBlur = 20;
    ctx.fillRect(game.enemy.x, game.enemy.y, game.enemy.width, game.enemy.height);
    ctx.shadowBlur = 0;
    
    ctx.restore();
}

function gameLoop(timestamp) {
    const deltaTime = Math.min((timestamp - game.lastTime) / 1000, 0.1);
    game.lastTime = timestamp;
    update(deltaTime);
    draw();
    requestAnimationFrame(gameLoop);
}

function resumeGame() { game.paused = false; document.getElementById('pauseMenu').classList.add('hidden'); }
function returnToMenu() { game.running = false; game.screen = 'menu'; document.querySelectorAll('.menu').forEach(m => m.classList.add('hidden')); document.getElementById('mainMenu').classList.remove('hidden'); }
function showSettings() { document.getElementById('mainMenu').classList.add('hidden'); document.getElementById('settingsMenu').classList.remove('hidden'); }
function hideSettings() { document.getElementById('settingsMenu').classList.add('hidden'); document.getElementById('mainMenu').classList.remove('hidden'); }

init();
</script>
